import { readFileSync } from "fs";
import path from "path";
import {
  TAppsmithActionCollection,
  TAppsmithApplication,
} from "~/types/base.types";
import { parse } from "@babel/parser";
import generator from "@babel/generator";
import traverse from "@babel/traverse";
import {
  TAppsmithJSAction,
  TAppsmithJSPlugin,
} from "./types/datasources.types";

type Variable = {
  name: string;
  value: string;
};

type Function = {
  name: string;
  fullyQualifiedName: string;
  body: string;
  jsArguments: Array<{ name: string }>;
  isAsync: boolean;
  collectionId: string;
};

export class JsObject {
  name: string;
  #body: string = "";
  actionCollectionList: TAppsmithApplication["actionCollectionList"] = [];
  actionList: TAppsmithJSPlugin[] = [];

  constructor(name: string, relativePath: string) {
    if (!name) {
      throw new Error("JsObject name cannot be empty");
    }

    if (!relativePath) {
      throw new Error("JsObject path cannot be empty");
    }

    this.name = name;
    const error = new Error();
    const stackLines = error.stack.split("\n");
    // Assuming the method call is the third entry in the stack
    const methodCallLine = stackLines[2];
    // Extract file path from the stack line
    const match = methodCallLine.match(/\((.*):\d+:\d+\)$/);
    let dirName = "";
    if (match) {
      const filePath = match[1];
      dirName = path.dirname(filePath);
    } else {
      throw new Error("Could not find file path from stack");
    }
    const absolutePath = path.join(dirName, relativePath);
    try {
      const jsObj = readFileSync(absolutePath, "utf-8");
      this.#body = jsObj;
    } catch (e) {
      throw new Error("Invalid file path");
    }

    const { variables, functions } = this.#extractCodeAndVariables();
    this.#setVariables(variables);
    this.#setActionList(functions);
  }

  #setActionList(functions: Function[]) {
    functions.forEach(
      ({
        name,
        fullyQualifiedName,
        body: generatedCode,
        jsArguments,
        isAsync,
        collectionId,
      }) => {
        const actionConfig: TAppsmithJSAction = {
          name,
          fullyQualifiedName, // to be filled later  objectName.functionName
          datasource: {
            name: "UNUSED_DATASOURCE",
            pluginId: "js-plugin",
            messages: [],
            isAutoGenerated: false,
            deleted: false,
            policies: [],
            userPermissions: [],
          },
          pageId: "", // to be filled later
          collectionId,
          actionConfiguration: {
            timeoutInMillisecond: 10000.0,
            paginationType: "NONE",
            encodeParamsToggle: true,
            body: generatedCode,
            selfReferencingDataPaths: [],
            jsArguments,
            isAsync,
          },
          executeOnLoad: false,
          clientSideExecution: true,
          dynamicBindingPathList: [{ key: "body" }],
          isValid: true,
          invalids: [],
          messages: [],
          jsonPathKeys: [generatedCode],
          userSetOnLoad: false,
          confirmBeforeExecute: false,
          policies: [],
          userPermissions: [],
          createdAt: "2023-07-13T12:30:41Z",
        };

        this.actionList.push({
          pluginType: "JS",
          pluginId: "js-plugin",
          unpublishedAction: actionConfig,
          publishedAction: actionConfig,
          id: fullyQualifiedName,
          deleted: false,
          gitSyncId: "",
        });
      }
    );
  }

  #setVariables(variables: Variable[]) {
    const collectionConfig: TAppsmithActionCollection = {
      name: this.name,
      pageId: "",
      pluginId: "js-plugin",
      pluginType: "JS",
      actions: [],
      archivedActions: [],
      body: this.#body,
      variables,
      userPermissions: [],
    };

    this.actionCollectionList.push({
      unpublishedCollection: collectionConfig,
      publishedCollection: collectionConfig,
      id: this.name,
      deleted: false,
      gitSyncId: "",
    });
  }

  #extractCodeAndVariables(): {
    variables: Variable[];
    functions: Function[];
  } {
    const ast = parse(this.#body, { sourceType: "module" });
    let exportedObject;

    traverse(ast, {
      ExportDefaultDeclaration(path) {
        exportedObject = path.node.declaration.properties;
      },
    });

    const variables: Variable[] = [];
    const functions: Function[] = [];

    exportedObject.forEach((property) => {
      const { key, type } = property;
      const generatedCode = generator(property).code;
      if (
        type === "FunctionExpression" ||
        type === "ArrowFunctionExpression" ||
        type === "ObjectMethod"
      ) {
        // Function property
        const isAsync = property.async;
        console.log(this.name);

        functions.push({
          name: key.name,
          fullyQualifiedName: `${this.name}.${key.name}`,
          body: generatedCode,
          jsArguments: property.params.map((param) => ({ name: param.name })),
          isAsync,
          collectionId: this.name,
        });
      } else {
        variables.push({
          name: key.name,
          value: JSON.stringify(eval(generatedCode)),
        });
      }
    });

    return {
      variables,
      functions,
    };
  }
}
